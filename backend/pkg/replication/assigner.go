package replication
































































































}	return nil		}		}			seen[replicaID] = true			}				return fmt.Errorf("partition %d has duplicate replica %d", partitionID, replicaID)			if seen[replicaID] {		for _, replicaID := range replicas {		seen := make(map[int32]bool)		// Check for duplicate replicas				}			return fmt.Errorf("partition %d has %d replicas, expected %d", partitionID, len(replicas), replicationFactor)		if len(replicas) != int(replicationFactor) {				}			return fmt.Errorf("missing assignment for partition %d", partitionID)		if !exists {		replicas, exists := assignments[partitionID]	for partitionID := int32(0); partitionID < numPartitions; partitionID++ {		}		return fmt.Errorf("assignment has %d partitions, expected %d", len(assignments), numPartitions)	if len(assignments) != int(numPartitions) {func ValidateAssignment(assignments map[int32][]int32, numPartitions int32, replicationFactor int16) error {// ValidateAssignment validates a replica assignment}	return replicas[0]	}		return -1	if len(replicas) == 0 {func GetLeader(replicas []int32) int32 {// GetLeader returns the leader for a partition (first replica)}	return assignments, nil		}		assignments[partitionID] = replicas				}			replicas = append(replicas, ra.brokers[brokerIndex])			brokerIndex := (startIndex + i) % len(ra.brokers)		for i := 0; i < int(replicationFactor); i++ {				startIndex := int(partitionID) % len(ra.brokers)		// Start from different broker for each partition to distribute leaders				replicas := make([]int32, 0, replicationFactor)	for partitionID := int32(0); partitionID < numPartitions; partitionID++ {		// Partition 2: [3, 1, 2] (leader=3)	// Partition 1: [2, 3, 1] (leader=2)	// Partition 0: [1, 2, 3] (leader=1)	// Example with 3 brokers [1,2,3], 3 partitions, RF=3:	// Round-robin assignment		assignments := make(map[int32][]int32)		}		return nil, fmt.Errorf("replication factor must be positive")	if replicationFactor <= 0 {		}		return nil, fmt.Errorf("replication factor %d exceeds number of brokers %d", replicationFactor, len(ra.brokers))	if int(replicationFactor) > len(ra.brokers) {		}		return nil, fmt.Errorf("no brokers available")	if len(ra.brokers) == 0 {func (ra *ReplicaAssigner) AssignReplicas(numPartitions int32, replicationFactor int16) (map[int32][]int32, error) {// Returns a map: partitionID -> []replicaIDs// AssignReplicas assigns replicas for a topic using round-robin algorithm}	}		brokers: brokers,	return &ReplicaAssigner{func NewReplicaAssigner(brokers []int32) *ReplicaAssigner {// NewReplicaAssigner creates a new replica assigner}	brokers []int32type ReplicaAssigner struct {// ReplicaAssigner assigns replicas to brokers for topic partitions)	"fmt"import (package replication// Copyright 2025 Takhin Data, Inc.